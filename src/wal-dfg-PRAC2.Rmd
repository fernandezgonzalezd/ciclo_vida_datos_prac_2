---
title: 'Práctica 2: Limpieza y validación de los datos'
author: "Waziri Ajibola Lawal, David Fernández González"
date: "1/3/2021"
output:
  pdf_document: default
  html_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

******
# Detalles de la actividad

******

## Descripción

En esta práctica se elabora un caso práctico orientado a aprender a identificar los datos
relevantes para un proyecto analítico y usar las herramientas de integración, limpieza, validación
y análisis de las mismas.

## Competencias

En esta práctica se desarrollan las siguientes competencias del Máster de Data Science:

* Capacidad de analizar un problema en el nivel de abstracción adecuado a cada situación y aplicar las habilidades y conocimientos adquiridos para abordarlo y resolverlo.

* Capacidad para aplicar las técnicas específicas de tratamiento de datos (integración, transformación, limpieza y validación) para su posterior análisis.


## Objetivos
Los objetivos concretos de esta práctica son:

* Aprender a aplicar los conocimientos adquiridos y su capacidad de resolución de problemas en entornos nuevos o poco conocidos dentro de contextos más amplios o multidisciplinares.
* Saber identificar los datos relevantes y los tratamientos necesarios (integración, limpieza y validación) para llevar a cabo un proyecto analítico.
* Aprender a analizar los datos adecuadamente para abordar la información contenida en los datos.
* Identificar la mejor representación de los resultados para aportar conclusiones sobre el
problema planteado en el proceso analítico.
* Actuar con los principios éticos y legales relacionados con la manipulación de datos en función del ámbito de aplicación.
* Desarrollar las habilidades de aprendizaje que les permitan continuar estudiando de un modo que tendrá que ser en gran medida autodirigido o autónomo.
* Desarrollar la capacidad de búsqueda, gestión y uso de información y recursos en el ámbito de la ciencia de datos.


******
# Realización de la práctica
******

## 1. Descripción del dataset.  ¿Por qué es importante y qué pregunta/problema pretende responder?

El conjunto de datos que se va a analizar es el de Red Wine Quality y se ha obtenido a partir de este enlace en Kaggle (https://www.kaggle.com/uciml/red-wine-quality-cortez-et-al-2009). El conjunto de datos de vino tinto contiene 1599 observaciones, 11 predictores y 1 valor categórico que indica la calidad del vino. Entre los campos de este conjunto de datos, encontramos los siguientes:

* fixed acidity: la mayoría de los ácidos involucrados con el vino, o fijos o no volátiles (no se evaporan fácilmente).

* volatile acidity: cantidad de ácido acético en el vino.

* citric acid: cantidad de ácido cítrico en el vino.

* residual sugar: cantidad de azúcar residual en el vino.

* chlorides: cantidad de sal de potasio en el vino.

* free sulfur dioxide: El SO2 existe en equilibrio, demasiado afectará la salud.

* total sulfur dioxide: cantidad de total de S02 en el vino.

* density: la densidad del vino se acerca a la del agua dependiendo del porcentaje de alcohol y del contenido de azúcar.

* pH: describe qué tan ácido o básico es un vino.

* sulphates: un aditivo para el vino que puede contribuir a los niveles de dióxido de azufre (S02), que actúa como antimicrobiano y antioxidante.

* alcohol: el porcentaje de contenido de alcohol del vino.

* quality: valor que describe la calidad del vino (basada en datos sensoriales, puntuación entre 0 y 10).


El objetuvo principal es encontrar que variables ofrecen más información sobre la calidad del vino. También intentaremos hacer predicciones de la calidad de un vino, y comprobar si se corresponde con su calidad real.

\newpage
## 2. Integración y selección de los datos de interés a analizar.

Primer contacto con el conjunto de datos, visualizamos su estructura.  

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Cargamos los paquetes R que vamos a usar
library(ggplot2)
library(dplyr)
library(psych)
library(nortest)

if(!require(corrplot)){
    install.packages('corrplot', repos='http://cran.us.r-project.org')
    library(corrplot)
}

if(!require(ggcorrplot)){
    install.packages('ggcorrplot', repos='http://cran.us.r-project.org')
    library(ggcorrplot)
}

# Cargamos el fichero de datos
redWineData <- read.csv('winequality-red.csv',stringsAsFactors = FALSE, header = TRUE)
#filas=dim(redWineData)[1]

attach(redWineData)

# Verificamos la dimension del conjunto de datos
dim(redWineData)

# Verificamos la estructura del conjunto de datos
sapply(redWineData, class)

# Verificamos la estructura del conjunto de datos
str(redWineData)

# Verificamos la distribución de los datos  
head(redWineData)
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Estadísticas básicas, verificamos algunas métricas sobre las variables
summary(redWineData)

summary(redWineData$quality)


```
Hay 1599 observaciones de 12 variables numéricas.

Quantity es una variable categórica y discreta, con una escala de 0 a 10. Los valores varían sólo de 3 a 8, con una media de 5,6 y una mediana de 6.
Todas las demás variables parecen ser cantidades continuas (con la excepción de los sufijos .sulfur.dioxide).

Todos los predictores son valores numéricos, los resultados son enteros.

\newpage
## 3. Limpieza de los datos.


### 3.1. ¿Los datos contienen ceros o elementos vacíos? ¿Cómo gestionarías cada uno de estos casos?
Como podemos observar, no existen valores vacios en nuestro conjunto de datos.
```{r echo=TRUE, message=FALSE, warning=FALSE}
# Verificamos si existen valores vacios en el conjunto de datos
colSums(is.na(redWineData))
```


### 3.2. Identificación y tratamiento de valores extremos.
Las métricas del conjunto de datos nos muestran que la mayoría de las variables tienen un rango amplio en comparación con el rango intercuartil, lo que puede indicar una dispersión en los datos y la presencia de valores atípicos. Investigamos más a fondo produciendo diagramas de caja para cada una de las variables:

```{r echo=TRUE, message=FALSE, warning=FALSE}
oldpar = par(mfrow = c(2,6))
for ( i in 1:11 ) {
  boxplot(redWineData[[i]])
  mtext(names(redWineData)[i], cex = 0.8, side = 1, line = 2)
}
par(oldpar)
```

Para obtener mas información sobre la posición de los valores atípicos, podemos usar la funciñon pairs() con la que obtendremos una matriz de gráfico de dispersión.

```{r echo=TRUE, message=FALSE, warning=FALSE}
pairs(redWineData[, -grep("quality", colnames(redWineData))])
```

Podemos ver que todas las variables contienen valores atípicos. Estos valores atípicos se encuentran en los extremos superiores.

```{r, tratamiento_outliers,eval=TRUE,echo=TRUE}
eliminated_outliers <- redWineData
for (i in 1:11) {
  # Q <- quantile(redWineData[[i]], probs=c(.25, .75), na.rm = FALSE)
  # iqr <- IQR(redWineData[[i]])
  # up <-  Q[2]+1.5*iqr # Upper Range
  # low <- Q[1]-1.5*iqr # Lower Range
  # eliminated_outliers <- subset(redWineData, redWineData[[i]] > (Q[1] - 1.5*iqr) & redWineData[[i]] < (Q[2]+1.5*iqr))
  # ggbetweenstats(eliminated_outliers, quality, redWineData[[i]], outlier.tagging = TRUE)
  boxplot(redWineData[[i]], plot = FALSE)$out
  outliers <- boxplot(redWineData[[i]], plot = FALSE)$out
  eliminated_outliers <- eliminated_outliers[-which(eliminated_outliers[[i]] %in% outliers), ]
}

dim(eliminated_outliers)
```

## 4. Análisis de los datos

### 4.1. Selección de los grupos de datos que se quieren analizar/comparar (planificación de los análisis a aplicar).



Podemos observar que casi todas las distribuciones están sesgadas positivamente. Las variables pH, density y quality tienen una distribución aproximadamente normal.

### 4.2. Comprobación de la normalidad y homogeneidad de la varianza.
Procedemos a la generación de histogramas y de las gráficas quantile-quantile para entender la distribución de cada variable (predictor).


```{r, normalidad,eval=TRUE,echo=TRUE}

par(mfrow=c(2,2))
for(i in 1:ncol(eliminated_outliers)) {
  if (is.numeric(eliminated_outliers[,i])){
    qqnorm(eliminated_outliers[,i],main = paste("Normal Q-Q Plot for ",colnames(eliminated_outliers)[i]))
    qqline(eliminated_outliers[,i],col="red")
    hist(eliminated_outliers[,i], 
      main=paste("Histogram for ", colnames(eliminated_outliers)[i]), 
      xlab=colnames(eliminated_outliers)[i], freq = FALSE)
  }
}


```



\newpage

### 4.3. Aplicación de pruebas estadísticas para comparar los grupos de datos. En función de los datos y el objetivo del estudio, aplicar pruebas de contraste de hipótesis, correlaciones, regresiones, etc. Aplicar al menos tres métodos de análisis diferentes.

## 5. Representación de los resultados a partir de tablas y gráficas.

## 6. Resolución del problema. A partir de los resultados obtenidos, ¿cuáles son las conclusiones? ¿Los resultados permiten responder al problema?


\newpage
## Tabla de contribuciones al trabajo

```{r, contribuciones,eval=TRUE,echo=TRUE}
contribuciones <- matrix(c("Investigación previa","WAjibolaL,DFdezGlez","Redacción de las respuestas","WAjibolaL,DFdezGlez","Desarrollo código","WAjibolaL,DFdezGlez"),ncol=2,byrow=TRUE)
colnames(contribuciones) <- c("Contribuciones","Firmas")
rownames(contribuciones) <- c("","","")
contribuciones <- as.table(contribuciones)
contribuciones

```
\newpage

Procedemos a la generación de histogramas para entender la distribución de cada variable (predictor).

```{r, seleccion_grupos,eval=TRUE,echo=TRUE}
par(mfrow=c(1,3))

# # Histograma de la variable Fixed Acidity
# with(eliminated_outliers, hist(fixed.acidity, main = "Red Wine fixed acidity", xlab="Red Wine Fixed Acidity # concentration", col="Blue"))

# Histograma de la variable Volatile Acidity
# with(eliminated_outliers, hist(volatile.acidity, main = "Red Wine volatile Acidity distribution", xlab="Red Wine Volatile Acidity concentration", col="Orange"))

# Histograma de la variable Citric Acid
# with(eliminated_outliers, hist(citric.acid, main = "Red Wine Citric acid distribution", xlab="Red Wine Citric Acid concentration", col="Yellow"))

# Histograma de la variable Residual Sugar
# with(eliminated_outliers, hist(residual.sugar, main = "Red Wine Residual Sugar distribution", xlab="Red Wine Residual Sugar concentration", col="Green"))
 
# Histograma de la variable Chlorides
# with(eliminated_outliers, hist(chlorides, main = "Red Wine Chloride distribution", xlab="Red Wine Chloride concentration", col="Cyan"))

# Histograma de la variable Free Sulfur Dioxide
# with(eliminated_outliers,  hist(free.sulfur.dioxide, main = "Red Wine Free Sulfur Dioxide distribution", xlab="Red Wine Free Sulfur Dioxide concentration", col="Violet"))

# Histograma de la variable Total Sulfur Dioxide
# with(eliminated_outliers, hist(total.sulfur.dioxide, main = "Red Wine Total Sulfur Dioxide distribution", xlab="Red Wine Total Sulfur Dioxide concentration", col="Magenta"))

# Histograma de la variable Alcohol
# with(eliminated_outliers, hist(alcohol, main = "Red Wine Alcohol distribution", xlab="Red Wine Alcohol concentration", col="Grey"))

# Histograma de la variable Density
# with(eliminated_outliers, hist(density, main = "Red Wine Density distribution", xlab="Density", col="Red"))

# Histograma de la variable pH
# with(eliminated_outliers, hist(pH, main = "Red Wine pH distribution", xlab="Red Wine pH concentration",col="Brown"))

# Histograma de la variable Sulphates
# with(eliminated_outliers, hist(sulphates, main = "Red Wine sulphates distribution", xlab="Red Wine sulphates concentration", col="Dark Blue"))

# Histograma de la variable quality
# with(eliminated_outliers, hist(quality, breaks=6, col="Dark Green",xlab="Red Wine Quality Rating, low=1 high=7", main="Red Wine Quality  distribution"))


par(mfrow=c(1,2))

for (i in 1:12) {
  ## Have a look at the densities
  # plot(density(eliminated_outliers[[i]]), main = names(eliminated_outliers)[i], xlab = "");
  
  ## Plot using a qqplot
  # qqnorm(eliminated_outliers[[i]]);qqline(eliminated_outliers[[i]], col = 2)
}


```






### Exportación de los datos preprocesados

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Exportación de los datos limpios en .csv
write.csv(eliminated_outliers, "winequality-red_data_clean.csv")
```

## Pruebas estadísticas

### Correlaciones

Mediante la matriz de correlación, podemos ver que la calidad de los vinos está relacionada en gran medida con las variables sulphates y alcohol.

Tambien podemos observar las correlaciones entre las variables fixed.acidity - density (correlación fuerte), fixed.acidity - pH (correlación fuerte), fixed.acidity - citric.acid, volatie.acidity - citric.acid y total.sulfur.dioxide - free.sulfur.dioxide.

```{r echo=TRUE, message=FALSE, warning=FALSE}
corrplot(cor(eliminated_outliers), method = "circle")

ggcorrplot(cor(eliminated_outliers), hc.order = TRUE, type = "lower", lab = TRUE, insig = "blank")
```

Estas correlaciones se pueden verificar mediantes las pruebas de correlaciones de la siguiente manera:

```{r echo=TRUE, message=FALSE, warning=FALSE}
# cor.test(eliminated_outliers$sulphates, eliminated_outliers$quality)

# cor.test(eliminated_outliers$alcohol, eliminated_outliers$quality)
```


```{r echo=TRUE, message=FALSE, warning=FALSE}
# library(nortest)
# alpha = 0.05
# col.names = colnames(eliminated_outliers)
# for (i in 1:ncol(eliminated_outliers)) {
#   if (i == 1) cat("Variables que no siguen una distribución normal:\n")
#   if (is.integer(eliminated_outliers[,i]) | is.numeric(eliminated_outliers[,i])) {
#     p_val = ad.test(eliminated_outliers[,i])$p.value
#     if (p_val < alpha) {
#       cat(col.names[i])
#       # Format output
#       if (i < ncol(eliminated_outliers) - 1) cat(", ")
#       if (i %% 3 == 0) cat("\n")
#     }
#   }
# }
```

```{r, correlacion,eval=TRUE,echo=TRUE}


cor(x=eliminated_outliers[1:11], y=eliminated_outliers$quality)



```
Podemos ver que las variables están correlacionadas con quality de la siguiente manera
From previous we see that the following variables are correlated with quality:


* alcohol (+++)
* sulphates (+++)
* volatile.acidity (--)
* citric.acid (++)
* fixed.acidity (+)
* total.sulfur.dioxide (-)
* density (-)
* chlorides (-)

